<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Career Recommendation App</title>
    <!-- We'll load all our dependencies here to make sure they're ready -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- We're adding the Chart.js library for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Custom styles for the checkbox-label to give it a button-like appearance */
        .checkbox-label {
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        /* Style for when the checkbox is checked */
        input[type="checkbox"]:checked + .checkbox-label {
            background-color: #3b82f6; /* A shade of blue */
            color: white;
            box-shadow: 0 4px 14px rgba(59, 130, 246, 0.4);
            transform: scale(1.05);
        }

        /* Simple animation for the recommendation box */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fadeIn {
            animation: fadeIn 0.5s ease-out forwards;
        }

        /* Styles for the loading spinner */
        .loader {
            border: 4px solid #f3f3f3; /* Light grey */
            border-top: 4px solid #3b82f6; /* Blue */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900">
    <div id="root"></div>

    <script>
        // Use a simple load event listener to ensure all external scripts are loaded
        window.addEventListener('load', () => {
            const { createElement, useState, useEffect, useRef } = React;
            const { createRoot } = ReactDOM;
            
            // Your API key has been added here.
            // WARNING: For a public website, it's a security risk to expose your API key directly in the frontend code.
            // A more secure approach is to use a backend server to handle API calls.
            // For now, this is all you need to get it working locally.
            const API_KEY = "AIzaSyDBeNSWXyM91a7zhYEjC6pMifQANVJYYWk";


            // This is the main application component using React hooks
            const App = () => {
                // State to hold the selected options in a nested structure
                const [selectedOptions, setSelectedOptions] = useState({
                    'Technical Skills': {},
                    'Soft Skills': {},
                    'Domain Interests': {},
                    'Motivations': {},
                });
                // State to store the recommendation result
                const [recommendation, setRecommendation] = useState(null);
                // State for the warning message
                const [showWarning, setShowWarning] = useState(false);
                // New state to handle the loading spinner while the API is working
                const [isLoading, setIsLoading] = useState(false);
                // State for the chart data
                const [chartData, setChartData] = useState(null);
                const [chartInstance, setChartInstance] = useState(null);
                // State to hold the chat history
                const [chatHistory, setChatHistory] = useState([]);
                // State for the chat input field
                const [chatInput, setChatInput] = useState('');
                // State for the chat loader
                const [chatLoading, setChatLoading] = useState(false);
                // State for API error message
                const [apiError, setApiError] = useState(null);

                // Ref for the chat messages container to enable auto-scrolling
                const messagesEndRef = useRef(null);

                // Scroll to the bottom of the chat window whenever a new message is added
                const scrollToBottom = () => {
                    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
                };

                // Updated data structure for questions, now with nested options for some categories
                const questions = {
                    "Technical Skills": {
                        options: [
                            { name: 'Programming', subOptions: ['Python', 'JavaScript', 'Java', 'C++', 'Swift'] },
                            { name: 'Mechanical Design', subOptions: ['CAD Software', 'Prototyping', 'Thermodynamics'] },
                            { name: 'Statistics', subOptions: ['Data Analysis', 'Predictive Modeling'] },
                            { name: 'Writing Skills', subOptions: ['Content Creation', 'Technical Documentation', 'Creative Writing'] },
                            { name: 'Medical Knowledge', subOptions: ['Anatomy', 'Pharmacology', 'Patient Care'] },
                            { name: 'Project Management', subOptions: ['Agile', 'Scrum', 'Waterfall'] },
                            { name: 'Social Media', subOptions: ['Content Strategy', 'Community Management', 'Analytics'] },
                            { name: 'Creativity', subOptions: ['Visual Arts', 'Music', 'Storytelling'] }
                        ],
                    },
                    "Soft Skills": {
                        options: [
                            { name: 'Teamwork', subOptions: ['Collaboration', 'Conflict Resolution'] },
                            { name: 'Attention to Detail', subOptions: ['Editing', 'Quality Assurance'] },
                            { name: 'Patience', subOptions: ['Customer Support'] },
                            { name: 'Empathy', subOptions: ['User Research', 'Mentoring'] },
                            { name: 'Leadership', subOptions: ['Team Management', 'Strategic Planning'] },
                            { name: 'Analytical Thinking', subOptions: ['Critical Thinking', 'Data Interpretation'] },
                            { name: 'Sales Communication', subOptions: ['Negotiation', 'Active Listening'] }
                        ],
                    },
                    "Domain Interests": {
                        options: [
                            { name: 'Technology', subOptions: ['Software', 'Hardware', 'Cybersecurity'] },
                            { name: 'Design', subOptions: ['UI/UX', 'Graphic Design', 'Product Design'] },
                            { name: 'Education', subOptions: ['Teaching', 'Curriculum Development'] },
                            { name: 'Healthcare', subOptions: ['Patient Care', 'Public Health'] },
                            { name: 'Marketing', subOptions: ['Digital Marketing', 'Brand Strategy'] },
                            { name: 'Engineering', subOptions: ['Civil', 'Electrical', 'Aerospace'] },
                            { name: 'Research', subOptions: ['Scientific', 'Market Research'] }
                        ],
                    },
                    "Motivations": {
                        options: [
                            { name: 'Problem Solving', subOptions: ['Puzzles', 'Debugging'] },
                            { name: 'Helping Others', subOptions: ['Mentoring', 'Community Service'] },
                            { name: 'Creative Expression', subOptions: ['Art', 'Music'] },
                            { name: 'Data Analysis', subOptions: ['Data Visualization', 'Statistical Modeling'] },
                            { name: 'Leading Projects', subOptions: ['Project Planning', 'Team Coordination'] },
                            { name: 'Storytelling', subOptions: ['Narrative Design', 'Writing'] },
                            { name: 'Sales and Influence', subOptions: ['Persuasion', 'Networking'] }
                        ],
                    }
                };

                // Hardcoded data for careers and their associated traits
                const careerData = [
                    { career: "Software Engineer", skills: "Programming", soft_skills: "Analytical Thinking", domains: "Technology", description: "A professional who designs, develops, tests, and maintains software applications. They are skilled in coding, debugging, and problem-solving to create functional and efficient software." },
                    { career: "Data Scientist", skills: "Statistics", soft_skills: "Analytical Thinking", domains: "Research", description: "An expert in analyzing and interpreting large, complex datasets to extract meaningful insights and trends. They use a combination of statistics, programming, and domain knowledge to solve business problems." },
                    { career: "Marketing Manager", skills: "Social Media", soft_skills: "Leadership", domains: "Marketing", description: "A professional who oversees and develops marketing campaigns. They are responsible for promoting a company's brand, products, or services to a target audience and leading a team to achieve marketing goals." },
                    { career: "Mechanical Engineer", skills: "Mechanical Design", soft_skills: "Problem Solving", domains: "Engineering", description: "A professional who designs, analyzes, manufactures, and maintains mechanical systems. They apply principles of physics and materials science to create innovative solutions and products." },
                    { career: "Technical Writer", skills: "Writing Skills", soft_skills: "Attention to Detail", domains: "Technology", description: "A professional who creates clear and concise technical documentation, such as user manuals, how-to guides, and reference materials for software products or technical systems." },
                    { career: "Nurse", skills: "Medical Knowledge", soft_skills: "Patience", domains: "Healthcare", description: "A healthcare professional who provides patient care, administers medication, and educates patients and their families about various health conditions. They are compassionate and detail-oriented." },
                    { career: "Project Manager", skills: "Project Management", soft_skills: "Leadership", domains: "Technology", description: "A professional who plans, executes, and oversees projects from start to finish. They ensure projects are completed on time and within budget, managing resources and team collaboration." },
                    { career: "Graphic Designer", skills: "Creativity", soft_skills: "Attention to Detail", domains: "Design", description: "A professional who creates visual concepts, by hand or using computer software, to communicate ideas that inspire, inform, and captivate consumers. They work on logos, websites, advertisements, and more." },
                    { career: "Teacher", skills: "Writing Skills", soft_skills: "Empathy", domains: "Education", description: "An educator who facilitates learning and helps students acquire knowledge, skills, and values. They develop curriculum, provide instruction, and assess student performance." },
                    { career: "Accountant", skills: "Statistics", soft_skills: "Attention to Detail", domains: "Finance", description: "A professional who manages financial records for individuals or organizations. They are responsible for preparing and analyzing financial reports, and ensuring compliance with financial regulations." },
                    { career: "Sales Representative", skills: "Sales Communication", soft_skills: "Persuasion", domains: "Marketing", description: "A professional who is responsible for selling products or services to customers. They build relationships, understand customer needs, and negotiate to close sales." }
                ];
                
                // useEffect to re-render chart whenever chartData changes
                useEffect(() => {
                    if (chartData) {
                        renderChart(chartData);
                    }
                }, [chartData]);

                // useEffect to scroll to bottom when chat history updates
                useEffect(() => {
                    scrollToBottom();
                }, [chatHistory]);

                // Function to render the Chart.js graph
                const renderChart = (data) => {
                    const ctx = document.getElementById('careerChart');
                    // Destroy the previous chart instance if it exists to prevent overlap
                    if (chartInstance) {
                        chartInstance.destroy();
                    }
                    const newChartInstance = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: data.labels,
                            datasets: [{
                                label: 'Match Score',
                                data: data.scores,
                                backgroundColor: [
                                    'rgba(59, 130, 246, 0.8)',
                                    'rgba(147, 197, 253, 0.8)',
                                    'rgba(129, 140, 248, 0.8)',
                                    'rgba(251, 191, 36, 0.8)',
                                    'rgba(239, 68, 68, 0.8)'
                                ],
                                borderColor: [
                                    'rgba(59, 130, 246, 1)',
                                    'rgba(147, 197, 253, 1)',
                                    'rgba(129, 140, 248, 1)',
                                    'rgba(251, 191, 36, 1)',
                                    'rgba(239, 68, 68, 1)'
                                ],
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    ticks: {
                                        color: '#d1d5db' // text color for y-axis
                                    },
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.1)' // grid color
                                    }
                                },
                                x: {
                                    ticks: {
                                        color: '#d1d5db' // text color for x-axis
                                    },
                                    grid: {
                                        color: 'rgba(255, 255, 255, 0.1)' // grid color
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            return Match Score: ${context.raw};
                                        }
                                    }
                                }
                            }
                        }
                    });
                    setChartInstance(newChartInstance);
                };


                // Handles updating the state for both main options and sub-options
                const handleCheckboxChange = (category, optionName, subOption = null) => {
                    setSelectedOptions(prev => {
                        const newCategoryState = { ...prev[category] };

                        // If a main option is selected
                        if (subOption === null) {
                            if (newCategoryState[optionName]) {
                                // Deselecting main option, also clears all sub-options
                                delete newCategoryState[optionName];
                            } else {
                                // Selecting main option
                                newCategoryState[optionName] = [];
                            }
                        } else {
                            // If a sub-option is selected
                            const currentSubs = newCategoryState[optionName] || [];
                            if (currentSubs.includes(subOption)) {
                                newCategoryState[optionName] = currentSubs.filter(item => item !== subOption);
                            } else {
                                newCategoryState[optionName] = [...currentSubs, subOption];
                            }
                            if (newCategoryState[optionName].length === 0) {
                                delete newCategoryState[optionName];
                            }
                        }

                        return {
                            ...prev,
                            [category]: newCategoryState,
                        };
                    });
                };

                // Logic to find the best career recommendation and then generate a description with AI
                const getRecommendation = async () => {
                    // Collect all selected options, including sub-options
                    const allSelected = [];
                    for (const category in selectedOptions) {
                        for (const option in selectedOptions[category]) {
                            allSelected.push(option);
                            if (selectedOptions[category][option].length > 0) {
                                allSelected.push(...selectedOptions[category][option]);
                            }
                        }
                    }

                    // Check if at least one option from every category has been selected
                    const allCategoriesAnswered = Object.values(selectedOptions).every(catObj => Object.keys(catObj).length > 0);
                    if (!allCategoriesAnswered) {
                        setShowWarning(true);
                        setRecommendation(null);
                        setChartData(null);
                        return;
                    }

                    setShowWarning(false);
                    setIsLoading(true); // Start loading state
                    setApiError(null); // Clear any previous API errors

                    const scoreMap = {};
                    const weightMap = {
                        'skills': 3,
                        'soft_skills': 2,
                        'domains': 2
                    };

                    careerData.forEach(career => {
                        let score = 0;
                        const careerSkills = new Set(career.skills.split(',').map(s => s.trim().toLowerCase()));
                        const careerSoftSkills = new Set(career.soft_skills.split(',').map(s => s.trim().toLowerCase()));
                        const careerDomains = new Set(career.domains.split(',').map(s => s.trim().toLowerCase()));

                        const allSelectedLower = new Set(allSelected.map(s => s.toLowerCase()));

                        const skillIntersection = new Set([...allSelectedLower].filter(x => careerSkills.has(x)));
                        const softSkillIntersection = new Set([...allSelectedLower].filter(x => careerSoftSkills.has(x)));
                        const domainIntersection = new Set([...allSelectedLower].filter(x => careerDomains.has(x)));

                        score += skillIntersection.size * weightMap['skills'];
                        score += softSkillIntersection.size * weightMap['soft_skills'];
                        score += domainIntersection.size * weightMap['domains'];

                        scoreMap[career.career] = score;
                    });
                    
                    // Sort careers by score to find the top 5
                    const sortedCareers = Object.entries(scoreMap)
                        .sort(([, scoreA], [, scoreB]) => scoreB - scoreA)
                        .slice(0, 5);

                    // Prepare data for the chart
                    const chartLabels = sortedCareers.map(([career]) => career);
                    const chartScores = sortedCareers.map(([, score]) => score);
                    
                    setChartData({
                        labels: chartLabels,
                        scores: chartScores
                    });


                    let bestCareer = sortedCareers[0][0];

                    // Get the hardcoded career data for the best match
                    const recommendedCareer = careerData.find(c => c.career === bestCareer);
                    
                    // Construct the prompt for the AI model
                    const prompt = Generate a detailed and encouraging career description for a ${recommendedCareer.career}. Highlight how a person with interests in ${Object.keys(selectedOptions['Domain Interests']).join(', ')} and skills like ${allSelected.join(', ')} would thrive in this role. The description should be engaging and no more than 100 words.;

                    try {
                        let chatHistory = [];
                        chatHistory.push({ role: "user", parts: [{ text: prompt }] });
                        const payload = { contents: chatHistory };
                        // The apiKey variable is now initialized with your provided key.
                        const apiKey = API_KEY;
                        const apiUrl = https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey};

                        // Make the API call to the LLM
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        // Check for non-OK HTTP responses
                        if (!response.ok) {
                            throw new Error(HTTP error! status: ${response.status} - Please check your API key and network connection.);
                        }

                        const result = await response.json();
                        // Use optional chaining to safely access the generated text
                        const generatedDescription = result?.candidates?.[0]?.content?.parts?.[0]?.text;
                        
                        // Fallback to the hardcoded description if the API call fails or returns no content
                        const finalDescription = generatedDescription || recommendedCareer.description;

                        // Update the recommendation state with the new AI-generated text
                        setRecommendation({
                            career: recommendedCareer.career,
                            description: finalDescription
                        });
                        
                        // Fix: Initialize the chat history with the 'model' role, not 'ai'
                        setChatHistory([
                            { role: 'model', text: Hello! I can tell you more about your recommended career, ${recommendedCareer.career}. What would you like to know? }
                        ]);

                    } catch (error) {
                        console.error("Failed to generate description:", error);
                        setApiError("I'm sorry, an API error occurred. This could be due to a missing or invalid API key. Please check the code comments for details.");
                        // Fallback to the hardcoded description if a network or API error occurs
                        setRecommendation(recommendedCareer);
                    } finally {
                        setIsLoading(false); // End loading state
                    }
                };

                // Function to handle chatbot interaction
                const handleChatSubmit = async (e) => {
                    e.preventDefault();
                    if (!chatInput.trim()) return;

                    // Add user message to chat history
                    const newUserMessage = { role: 'user', text: chatInput };
                    const newChatHistory = [...chatHistory, newUserMessage];
                    setChatHistory(newChatHistory);
                    setChatInput('');
                    setChatLoading(true);
                    setApiError(null); // Clear any previous API errors

                    // Fix: The API expects the entire conversation history as an array of messages,
                    // not a single concatenated string. We will format the chat history
                    // to match the API's expected structure.
                    const formattedChatHistory = newChatHistory.map(msg => ({
                        role: msg.role === 'user' ? 'user' : 'model',
                        parts: [{ text: msg.text }]
                    }));
                    
                    // The prompt for the AI is now the full conversation history
                    const payload = { contents: formattedChatHistory };
                    const apiKey = API_KEY;
                    const apiUrl = https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey};
                    
                    let aiResponse = 'I am sorry, I am having trouble getting a response. Please try again or ask a different question.'; // Default fallback message

                    try {
                        // Make the API call for the chatbot response
                        const response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        // Check for non-OK HTTP responses
                        if (!response.ok) {
                            throw new Error(HTTP error! status: ${response.status} - Please check your API key and network connection.);
                        }
                        
                        const result = await response.json();
                        // Safely get the AI response text
                        aiResponse = result?.candidates?.[0]?.content?.parts?.[0]?.text || aiResponse;

                    } catch (error) {
                        console.error("Failed to get chat response:", error);
                        setApiError("I'm sorry, an API error occurred. This could be due to a missing or invalid API key. Please check the code comments for details.");
                        // aiResponse remains the fallback message
                    } finally {
                        // Add the AI response (or fallback) to chat history
                        setChatHistory(prev => [...prev, { role: 'model', text: aiResponse }]);
                        setChatLoading(false);
                    }
                };


                return (
                    createElement('div', { className: 'min-h-screen bg-gray-900 text-gray-200 p-4 sm:p-8 flex justify-center items-center' },
                        createElement('div', { className: 'w-full max-w-4xl bg-gray-800 rounded-3xl shadow-2xl my-8 p-6 md:p-12 border border-gray-700' },
                            createElement('header', { className: 'text-center mb-12' },
                                createElement('h1', { className: 'text-3xl md:text-5xl font-extrabold text-blue-500 mb-2' }, 'Find Your Path'),
                                createElement('p', { className: 'text-gray-400 text-lg' }, 'Select the skills and interests that best describe you to get a personalized career recommendation.')
                            ),
                            showWarning && (
                                createElement('div', { className: 'bg-yellow-900 border-l-4 border-yellow-500 text-yellow-300 p-4 rounded-lg mb-6 animate-pulse', role: 'alert' },
                                    createElement('p', { className: 'font-bold' }, 'Oops!'),
                                    createElement('p', null, 'Please select at least one option from every category to get your recommendation.')
                                )
                            ),
                            apiError && (
                                createElement('div', { className: 'bg-red-900 border-l-4 border-red-500 text-red-300 p-4 rounded-lg mb-6', role: 'alert' },
                                    createElement('p', { className: 'font-bold' }, 'API Error'),
                                    createElement('p', null, apiError)
                                )
                            ),
                            createElement('div', { className: 'space-y-10' },
                                Object.entries(questions).map(([category, { options }]) => (
                                    createElement('div', { key: category },
                                        createElement('h2', { className: 'text-xl md:text-2xl font-bold text-gray-300 mb-4 flex items-center' },
                                            createElement('span', { className: 'mr-2 text-blue-400' }, '💡'),
                                            category
                                        ),
                                        options.map(option => (
                                            createElement('div', { key: option.name, className: 'mb-4' },
                                                createElement('label', { className: 'inline-flex items-center' },
                                                    createElement('input', {
                                                        type: 'checkbox',
                                                        className: 'hidden',
                                                        checked: selectedOptions[category][option.name] !== undefined,
                                                        onChange: () => handleCheckboxChange(category, option.name),
                                                    }),
                                                    createElement('div', { className: 'checkbox-label transition-all duration-200 hover:shadow-lg bg-gray-700 text-gray-300 rounded-full px-4 py-2 hover:bg-gray-600 cursor-pointer' },
                                                        createElement('span', { className: 'ml-2 text-sm md:text-base font-medium' }, option.name)
                                                    )
                                                ),
                                                option.subOptions.length > 0 && selectedOptions[category][option.name] !== undefined && (
                                                    createElement('div', { className: 'mt-2 pl-6 flex flex-wrap gap-2 animate-fadeIn' },
                                                        option.subOptions.map(subOption => (
                                                            createElement('label', { key: subOption, className: 'inline-flex items-center' },
                                                                createElement('input', {
                                                                    type: 'checkbox',
                                                                    className: 'hidden',
                                                                    checked: selectedOptions[category][option.name].includes(subOption),
                                                                    onChange: () => handleCheckboxChange(category, option.name, subOption),
                                                                }),
                                                                createElement('div', { className: 'checkbox-label transition-all duration-200 hover:shadow-lg bg-gray-800 text-gray-400 rounded-full px-3 py-1 text-sm hover:bg-gray-700 cursor-pointer' },
                                                                    createElement('span', { className: 'ml-2' }, subOption)
                                                                )
                                                            )
                                                        ))
                                                    )
                                                )
                                            )
                                        ))
                                    )
                                ))
                            ),
                            createElement('button', {
                                onClick: getRecommendation,
                                disabled: isLoading, // Disable the button while loading
                                className: w-full bg-gradient-to-r from-blue-600 to-blue-700 text-white font-bold py-4 px-6 rounded-lg mt-10 transition duration-300 transform ${isLoading ? 'opacity-50 cursor-not-allowed' : 'hover:shadow-lg hover:from-blue-700 hover:to-blue-800 hover:-translate-y-1'}
                            }, isLoading ? 'Generating...' : 'Get My Career Recommendation'),
                            isLoading && (
                                createElement('div', { className: 'mt-6 flex justify-center items-center' },
                                    createElement('div', { className: 'loader' }),
                                    createElement('p', { className: 'ml-4 text-gray-400' }, 'Generating a personalized description...')
                                )
                            ),
                            recommendation && !isLoading && (
                                createElement('div', { className: 'mt-10 p-8 bg-gray-700 rounded-lg shadow-xl border border-blue-400 animate-fadeIn' },
                                    createElement('h3', { className: 'text-2xl md:text-4xl font-extrabold text-blue-300 mb-4' },
                                        createElement('span', { className: 'mr-2' }, '🚀'),
                                        recommendation.career
                                    ),
                                    createElement('p', { className: 'text-gray-400 leading-relaxed' }, recommendation.description)
                                )
                            ),
                            chartData && (
                                createElement('div', { className: 'mt-10 p-8 bg-gray-700 rounded-lg shadow-xl animate-fadeIn' },
                                    createElement('h3', { className: 'text-2xl md:text-3xl font-bold text-gray-300 mb-6 text-center' }, 'Top Career Matches'),
                                    createElement('div', { className: 'relative h-64 md:h-80' },
                                        createElement('canvas', { id: 'careerChart' })
                                    )
                                )
                            ),
                            recommendation && (
                                createElement('div', { className: 'mt-10 p-8 bg-gray-700 rounded-lg shadow-xl border border-gray-600 animate-fadeIn' },
                                    createElement('h3', { className: 'text-2xl md:text-3xl font-bold text-gray-300 mb-6' }, 'Career Counselor Chatbot'),
                                    createElement('div', { className: 'h-64 overflow-y-auto bg-gray-800 p-4 rounded-lg border border-gray-700 flex flex-col space-y-4' },
                                        chatHistory.map((msg, index) => (
                                            createElement('div', { key: index, className: flex ${msg.role === 'user' ? 'justify-end' : 'justify-start'} },
                                                createElement('div', { className: rounded-xl p-3 max-w-xs md:max-w-md ${msg.role === 'user' ? 'bg-blue-600 text-white' : 'bg-gray-600 text-gray-200'} },
                                                    createElement('p', null, msg.text)
                                                )
                                            )
                                        )),
                                        chatLoading && (
                                             createElement('div', { className: 'flex justify-start' },
                                                createElement('div', { className: 'rounded-xl p-3 bg-gray-600 text-gray-200' },
                                                    createElement('p', null, 'Typing...'),
                                                    createElement('div', { className: 'loader ml-2' })
                                                )
                                            )
                                        ),
                                        createElement('div', { ref: messagesEndRef })
                                    ),
                                    createElement('form', { onSubmit: handleChatSubmit, className: 'mt-4 flex gap-2' },
                                        createElement('input', {
                                            type: 'text',
                                            value: chatInput,
                                            onChange: (e) => setChatInput(e.target.value),
                                            className: 'flex-grow p-3 rounded-full bg-gray-800 text-gray-200 border border-gray-700 focus:outline-none focus:ring-2 focus:ring-blue-500',
                                            placeholder: 'Ask a question about your recommended career...',
                                            disabled: chatLoading
                                        }),
                                        createElement('button', {
                                            type: 'submit',
                                            disabled: chatLoading,
                                            className: bg-blue-600 text-white px-6 py-3 rounded-full font-bold transition duration-300 ${chatLoading ? 'opacity-50 cursor-not-allowed' : 'hover:bg-blue-700'}
                                        }, 'Send')
                                    )
                                )
                            )
                        )
                    )
                );
            };

            const container = document.getElementById('root');
            const root = createRoot(container);
            root.render(createElement(App));
        });
    </script>
</body>
</html>
